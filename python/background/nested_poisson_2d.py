#!/usr/bin/env python
# coding: utf-8

import ipyparallel as ipp


nprocs = 2
rc = ipp.Cluster(engine_launcher_class="mpi", n=nprocs).start_and_connect_sync()


get_ipython().run_cell_magic('px', '', 'from mpi4py import MPI\nimport dolfinx as df\nimport dolfinx.fem.petsc\nfrom petsc4py import PETSc\nimport numpy as np\nimport ufl\nimport matplotlib.pyplot as pl\nimport basix\nimport sys, os\nbasedir = \'\'\nif "__file__" in globals(): basedir = os.path.dirname(__file__)\nsys.path.append(os.path.join(basedir, os.path.pardir, os.path.pardir, \'python\'))\nimport utils\nimport pyvista as pv\nif __name__ == "__main__" and "__file__" in globals():\n    pv.OFF_SCREEN = True\nimport pathlib\nif __name__ == "__main__":\n    output_folder = pathlib.Path(os.path.join(basedir, "output"))\n    output_folder.mkdir(exist_ok=True, parents=True)\n')


get_ipython().run_cell_magic('px', '', 'def solve_nested_poisson_2d(ne, p=1, petsc_options=None):\n    """\n    A python function to solve a two-dimensional corner flow \n    problem on a unit square domain.\n    Parameters:\n    * ne - number of elements in each dimension\n    * p  - polynomial order of the solution (defaults to 1)\n    * petsc_options - a dictionary of petsc options to pass to the solver \n                      (defaults to an LU direct solver using the MUMPS library)\n    """\n\n    if petsc_options is None:\n        petsc_options = {"ksp_type": "preonly", \\\n                         "pc_type": "lu",\n                         "pc_factor_mat_solver_type": "mumps"}\n    pc_type = petsc_options.get(\'pc_type\', None)\n    \n    opts = PETSc.Options(); opts.clear()\n    for k, v in petsc_options.items(): opts[k] = v\n\n    # Describe the domain (a unit square)\n    # and also the tessellation of that domain into ne\n    # equally spaced squared in each dimension, which are\n    # subduvided into two triangular elements each\n    with df.common.Timer("Poisson Mesh"):\n        mesh = df.mesh.create_unit_square(MPI.COMM_WORLD, ne, ne, ghost_mode=df.mesh.GhostMode.none)\n\n    # Define the solution function space using Lagrange polynomials\n    # of order p\n    with df.common.Timer("Poisson Functions"):\n        V = df.fem.functionspace(mesh, ("Lagrange", p))\n        T1_i, T2_i = df.fem.Function(V), df.fem.Function(V)\n\n    with df.common.Timer("Poisson Dirichlet BCs"):\n        bcs = []\n        # Define the location of the boundary condition, x=0 and y=0\n        def boundary(x):\n            return np.logical_or(np.isclose(x[0], 0), np.isclose(x[1], 0))\n        boundary_dofs = df.fem.locate_dofs_geometrical(V, boundary)\n        # Specify the value and define a Dirichlet boundary condition (bc)\n        gD = df.fem.Function(V)\n        gD.interpolate(lambda x: np.exp(x[0] + x[1]/2.))\n        bcs.append(df.fem.dirichletbc(gD, boundary_dofs))\n\n    with df.common.Timer("Poisson Neumann BCs"):\n        # Get the coordinates\n        x = ufl.SpatialCoordinate(mesh)\n        # Define the Neumann boundary condition function\n        gN = ufl.as_vector((ufl.exp(x[0] + x[1]/2.), 0.5*ufl.exp(x[0] + x[1]/2.)))\n        # Define the right hand side function, h\n        h = -5./4.*ufl.exp(x[0] + x[1]/2.)\n    \n    with df.common.Timer("Poisson Forms"):\n        T1_a, T2_a = ufl.TrialFunction(V), ufl.TrialFunction(V)\n        T1_t, T2_t = ufl.TestFunction(V),  ufl.TestFunction(V)\n        # Get the unit vector normal to the facets\n        n = ufl.FacetNormal(mesh)\n        # Define the integral to be assembled into the stiffness matrix\n        Si = lambda T_t, T_a: ufl.inner(ufl.grad(T_t), ufl.grad(T_a))*ufl.dx\n        S = df.fem.form([[Si(T1_t, T1_a), None], [None, Si(T2_t, T2_a)]])\n        # Define the integral to be assembled into the forcing vector,\n        # incorporating the Neumann boundary condition weakly\n        fi = lambda T_t: T_t*h*ufl.dx + T_t*ufl.inner(gN, n)*ufl.ds\n        f = df.fem.form([fi(T1_t), fi(T2_t)])\n\n    with df.common.Timer("Poisson Assemble"):\n        A = df.fem.petsc.assemble_matrix_block(S, bcs=bcs)\n        A.assemble()\n\n        b = df.fem.petsc.assemble_vector_block(f, S, bcs=bcs)\n    \n    with df.common.Timer("Batchelor Solve"):\n        ksp = PETSc.KSP().create(MPI.COMM_WORLD)\n        ksp.setOperators(A)\n        ksp.setFromOptions()\n        \n        if pc_type == "fieldsplit":\n            map_T, bs_T = V.dofmap.index_map, V.dofmap.index_map_bs\n            is_size_T1 = map_T.size_local*bs_T\n            is_first_T1 = map_T.local_range[0]*bs_T + map_T.local_range[0]\n            is_T1 = PETSc.IS().createStride(is_size_T1, is_first_T1, 1, comm=PETSc.COMM_SELF)\n            is_size_T2 = map_T.size_local\n            is_first_T2 = is_first_T1 + map_T.size_local*bs_T\n            is_T2 = PETSc.IS().createStride(is_size_T2, is_first_T2, 1, comm=PETSc.COMM_SELF)\n            ksp.getPC().setFieldSplitIS(("T1", is_T1), ("T2", is_T2))\n\n        # Compute the solution\n        x = A.createVecRight()\n        ksp.solve(b, x)\n\n        # Extract the velocity and pressure solutions for the coupled problem\n        offset = V.dofmap.index_map.size_local*V.dofmap.index_map_bs\n        T1_i.x.array[:offset] = x.array_r[:offset]\n        T2_i.x.array[:(len(x.array_r) - offset)] = x.array_r[offset:]\n        T1_i.x.scatter_forward()\n        T2_i.x.scatter_forward()\n\n    opts.clear()\n\n    return T1_i, T2_i\n')


get_ipython().run_cell_magic('px', '', 'if __name__ == "__main__":\n    ne = 4\n    p = 1\n    U = 1\n    petsc_options = {\n                     \'ksp_type\':\'preonly\', \n                     \'pc_type\':\'fieldsplit\', \n                     \'pc_fieldsplit_type\': \'additive\',\n                     \'ksp_converged_reason\':None,\n                     #\'ksp_view\':None,\n                     \'fieldsplit_T1_ksp_type\':\'preonly\',\n                     \'fieldsplit_T1_pc_type\':\'lu\',\n                     \'fieldsplit_T1_pc_factor_mat_solver_type\':\'mumps\',\n                     \'fieldsplot_T1_ksp_converged_reason\':None,\n                     \'fieldsplit_T2_ksp_type\':\'preonly\',\n                     \'fieldsplit_T2_pc_type\':\'lu\',\n                     \'fieldsplit_T2_pc_factor_mat_solver_type\':\'mumps\',\n                     \'fieldsplot_T2_ksp_converged_reason\':None,\n                     }\n    petsc_options = {\n                     \'ksp_type\':\'preonly\',\n                     \'pc_type\':\'lu\',\n                     \'pc_factor_mat_solver_type\':\'mumps\',\n                     \'ksp_converged_reason\':None,\n    }\n    #petsc_options=None\n    T1, T2 = solve_nested_poisson_2d(ne, p=p, petsc_options=petsc_options)\n    T1.name = "T1"\n    T2.name = "T2"\n')


get_ipython().run_cell_magic('px', '', 'if __name__ == "__main__":\n    # plot the solution as a colormap\n    plotter_P1 = utils.plot_scalar(T1, gather=True, cmap=\'coolwarm\')\n    # plot the mesh\n    utils.plot_mesh(T1.function_space.mesh, plotter=plotter_P1, gather=True, show_edges=True, style="wireframe", color=\'k\', line_width=2)\n    # plot the values of the solution at the nodal points \n    utils.plot_scalar_values(T1, plotter=plotter_P1, gather=True, point_size=15, font_size=22, shape_color=\'w\', text_color=\'k\', bold=False)\n    # show the plot\n    #utils.plot_show(plotter_P1)\n    # save the plot\n    utils.plot_save(plotter_P1, output_folder / "2d_nested_poisson_T1_P1_solution.png")\n    comm = T1.function_space.mesh.comm\n    if comm.size > 1:\n        # if we\'re running in parallel (e.g. from a script) then save an image per process as well\n        plotter_P1_p = utils.plot_scalar(T1, gather=False, cmap=\'coolwarm\')\n        utils.plot_mesh(T1.function_space.mesh, plotter=plotter_P1_p, show_edges=True, style="wireframe", color=\'k\', line_width=2, gather=False)\n        utils.plot_scalar_values(T1, plotter=plotter_P1_p, point_size=15, font_size=22, shape_color=\'w\', text_color=\'k\', bold=False, gather=False)\n        utils.plot_save(plotter_P1_p, output_folder / "2d_nested_poisson_T1_P1_solution_p{:d}.png".format(comm.rank,))\n        utils.plot_show(plotter_P1_p)\n')


get_ipython().run_cell_magic('px', '', 'if __name__ == "__main__":\n    # plot the solution as a colormap\n    plotter_P1 = utils.plot_scalar(T2, gather=True, cmap=\'coolwarm\')\n    # plot the mesh\n    utils.plot_mesh(T2.function_space.mesh, plotter=plotter_P1, gather=True, show_edges=True, style="wireframe", color=\'k\', line_width=2)\n    # plot the values of the solution at the nodal points \n    utils.plot_scalar_values(T2, plotter=plotter_P1, gather=True, point_size=15, font_size=22, shape_color=\'w\', text_color=\'k\', bold=False)\n    # show the plot\n    utils.plot_show(plotter_P1)\n    # save the plot\n    utils.plot_save(plotter_P1, output_folder / "2d_nested_poisson_T2_P1_solution.png")\n    comm = T2.function_space.mesh.comm\n    if comm.size > 1:\n        # if we\'re running in parallel (e.g. from a script) then save an image per process as well\n        plotter_P1_p = utils.plot_scalar(T2)\n        utils.plot_mesh(T2.function_space.mesh, plotter=plotter_P1_p, show_edges=True, style="wireframe", color=\'k\', line_width=2)\n        utils.plot_scalar_values(T2, plotter=plotter_P1_p, point_size=15, font_size=22, shape_color=\'w\', text_color=\'k\', bold=False)\n        utils.plot_save(plotter_P1_p, output_folder / "2d_nested_poisson_T2_P1_solution_p{:d}.png".format(comm.rank,))\n        utils.plot_show(plotter_P1_p)\n')


get_ipython().run_cell_magic('px', '', 'def evaluate_error(T_i):\n    """\n    A python function to evaluate the l2 norm of the error in \n    the two dimensional Poisson problem given a known analytical\n    solution.\n    """\n    # Define the exact solution\n    x  = ufl.SpatialCoordinate(T_i.function_space.mesh)\n    Te = ufl.exp(x[0] + x[1]/2.)\n    \n    # Define the error between the exact solution and the given\n    # approximate solution\n    l2err = df.fem.assemble_scalar(df.fem.form((T_i - Te)*(T_i - Te)*ufl.dx))\n    l2err = T_i.function_space.mesh.comm.allreduce(l2err, op=MPI.SUM)**0.5\n    \n    # Return the l2 norm of the error\n    return l2err\n')


get_ipython().run_cell_magic('px', '', 'if __name__ == "__main__":\n    if MPI.COMM_WORLD.rank == 0:\n        # Open a figure for plotting\n        fig = pl.figure()\n        ax = fig.gca()\n    \n    petsc_options = {\'ksp_type\':\'preonly\', \n                     \'pc_type\':\'fieldsplit\', \n                     \'pc_fieldsplit_type\': \'additive\',\n                     \'fieldsplit_T1_ksp_type\':\'preonly\',\n                     \'fieldsplit_T1_pc_type\':\'lu\',\n                     \'fieldsplit_T1_pc_factor_mat_solver_type\':\'mumps\',\n                     \'fieldsplit_T2_ksp_type\':\'preonly\',\n                     \'fieldsplit_T2_pc_type\':\'lu\',\n                     \'fieldsplit_T1_pc_factor_mat_solver_type\':\'mumps\',}\n    petsc_options = {\'ksp_type\':\'preonly\', \n                     \'pc_type\':\'fieldsplit\', \n                     \'pc_fieldsplit_type\': \'additive\',\n                     \'fieldsplit_T1_ksp_type\':\'cg\',\n                     \'fieldsplit_T1_pc_type\':\'gamg\',\n                     \'fieldsplit_T1_ksp_rtol\':1.e-12,\n                     \'fieldsplit_T2_ksp_type\':\'cg\',\n                     \'fieldsplit_T2_pc_type\':\'gamg\',\n                     \'fieldsplit_T2_ksp_rtol\':1.e-12}\n    # petsc_options = {\'ksp_type\':\'cg\', \n    #                  \'pc_type\':\'gamg\',\n    #                  \'ksp_rtol\':1.e-12}\n    \n    # List of polynomial orders to try\n    ps = [1, 2]\n    # List of resolutions to try\n    nelements = [10, 20, 40, 80, 160]\n    # Keep track of whether we get the expected order of convergence\n    test_passes = True\n    # Loop over the polynomial orders\n    for p in ps:\n        # Accumulate the errors\n        errors_l2_1_a = []\n        errors_l2_2_a = []\n        # Loop over the resolutions\n        for ne in nelements:\n            # Solve the 2D Poisson problem\n            T1_i, T2_i = solve_nested_poisson_2d(ne, p, petsc_options=petsc_options)\n            # Evaluate the error in the approximate solution\n            l2error1 = evaluate_error(T1_i)\n            l2error2 = evaluate_error(T2_i)\n            # Print to screen and save if on rank 0\n            if T1_i.function_space.mesh.comm.rank == 0:\n                print(\'ne = \', ne, \', l2error1 = \', l2error1, \', l2error2 = \', l2error2)\n            errors_l2_1_a.append(l2error1)\n            errors_l2_2_a.append(l2error2)\n        \n        # Work out the order of convergence at this p\n        hs = 1./np.array(nelements)/p\n\n        # Fit a line to the convergence data\n        fit1 = np.polyfit(np.log(hs), np.log(errors_l2_1_a),1)\n        fit2 = np.polyfit(np.log(hs), np.log(errors_l2_2_a),1)\n\n        # Test if the order of convergence is as expected\n        test_passes = test_passes and fit1[0] > p+0.9 and fit2[0] > p+0.9\n        \n        if T1_i.function_space.mesh.comm.rank == 0:\n            print("***********  order of accuracy p={}, order1={:.2f}, order2={:.2f}".format(p,fit1[0],fit2[0]))\n        \n            # log-log plot of the error  \n            ax.loglog(hs,errors_l2_1_a,\'o-\',label=\'p={}, order1={:.2f}\'.format(p,fit1[0]))\n            ax.loglog(hs,errors_l2_2_a,\'ok--\',label=\'p={}, order2={:.2f}\'.format(p,fit2[0]))\n        \n    \n    # Write convergence to disk\n    if MPI.COMM_WORLD.rank == 0:\n        # Tidy up the plot\n        ax.set_xlabel(\'h\')\n        ax.set_ylabel(\'||e||_2\')\n        ax.grid()\n        ax.set_title(\'Convergence\')\n        ax.legend()\n\n        fig.savefig(output_folder / \'2d_poisson_convergence.pdf\')\n        \n        print("***********  convergence figure in output/2d_poisson_convergence.pdf")\n    \n    # Check if we passed the test\n    assert(test_passes)\n')


rc.shutdown()


if __name__ == "__main__" and "__file__" not in globals():
    from ipylab import JupyterFrontEnd
    app = JupyterFrontEnd()
    app.commands.execute('docmanager:save')
    get_ipython().system('jupyter nbconvert --TagRemovePreprocessor.enabled=True --TagRemovePreprocessor.remove_cell_tags="[\'main\', \'ipy\']" --TemplateExporter.exclude_markdown=True --TemplateExporter.exclude_input_prompt=True --TemplateExporter.exclude_output_prompt=True --NbConvertApp.export_format=script --ClearOutputPreprocessor.enabled=True --FilesWriter.build_directory=../../python/background --NbConvertApp.output_base=nested_poisson_2d 2.3e_nested_poisson_2d.ipynb')




